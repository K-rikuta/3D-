<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://unpkg.com/maplibre-gl@3/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3"></script>
    <script src="https://unpkg.com/three@r128/build/three.min.js"></script>
    <script src="https://unpkg.com/maplibre-gl-three@1"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts-gl@2.0.9/dist/echarts-gl.min.js"></script>

    <style>
      :root {
        --bg: #fdf6f0;
        --text: #6d4c41;
        --btn-border: #8d6e63;
      }
      html, body {
        width: 100%; height: 100%; margin: 0; padding: 0;
        overflow: hidden; font-family: 'M PLUS Rounded 1c', sans-serif;
        background-color: var(--bg); color: var(--text);
      }
      /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
      header {
        position: absolute; top: 15px; left: 20px; z-index: 10;
        pointer-events: none;
      }
      h1 {
        margin: 0; font-size: 24px; background: rgba(255,255,255,0.9);
        padding: 10px 20px; border-radius: 20px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.1); pointer-events: auto;
      }
      .legend {
        font-size: 11px; background: rgba(255,255,255,0.95);
        padding: 8px 12px; border-radius: 10px; margin-top: 5px;
        pointer-events: auto; display: inline-block;
      }
      .legend-item { display: inline-flex; align-items: center; margin-right: 10px; }
      .color-box { width: 12px; height: 12px; margin-right: 4px; border-radius: 3px; }

      /* ãƒœã‚¿ãƒ³ */
      .controls {
        position: absolute; bottom: 30px; left: 50%;
        transform: translateX(-50%); z-index: 10;
        background: rgba(255,255,255,0.9); padding: 10px 20px;
        border-radius: 30px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;
        width: 90%; max-width: 600px;
      }
      button {
        background: #fff; border: 1px solid var(--btn-border);
        color: var(--text); padding: 6px 14px; border-radius: 15px;
        font-family: 'M PLUS Rounded 1c'; font-weight: bold; cursor: pointer;
      }
      button:hover { background: #efebe9; }
      button.active { background: #6d4c41; color: #fff; border-color: #6d4c41; }

      #map { 
        position: absolute;
        width: 100vw; 
        height: 100vh; 
        z-index: 1;
      }
      #loading {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: var(--bg); display: flex; justify-content: center;
        align-items: center; flex-direction: column; z-index: 999;
      }
    </style>
  </head>
  <body>

    <div id="map"></div>

    <header>
      <h1>ğŸ» 3Dï½¸ï¾ï¾ï¾”ï¾ç›®æ’ƒãƒãƒƒãƒ—</h1>
      <div class="legend" id="legendArea">
        ğŸ–±ï¸ ãƒã‚¦ã‚¹ã§æ“ä½œ
      </div>
    </header>
    
    <div id="loading">
      <h2>åœ°å›³ãƒ‡ãƒ¼ã‚¿ã‚’å±•é–‹ä¸­...</h2>
      <p>â€»æ•°ç§’ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™</p>
    </div>
    
    <div class="controls" id="yearButtons"></div>

    <script>
      // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰Base64ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚‹
      const mapDataBase64 = "<?= mapData ?>";
      let japanMapData = null;

      // Base64ãƒ‡ã‚³ãƒ¼ãƒ‰å‡¦ç†ï¼ˆæ—¥æœ¬èªæ–‡å­—åŒ–ã‘å¯¾ç­–è¾¼ã¿ï¼‰
      function decodeBase64(str) {
        try {
          const binaryString = atob(str);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return new TextDecoder('utf-8').decode(bytes);
        } catch (e) {
          console.error("Decode failed", e);
          return null;
        }
      }

      // åœ°å›³ãƒ‡ãƒ¼ã‚¿ã®å¾©å…ƒï¼ˆGASæœªå±•é–‹æ™‚ã¯å¾Œã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯fetchï¼‰
      if (mapDataBase64 && !mapDataBase64.includes("<?")) {
        try {
          const jsonStr = decodeBase64(mapDataBase64);
          if (jsonStr) japanMapData = JSON.parse(jsonStr);
        } catch (e) {
          console.warn("Base64å±•é–‹ã«å¤±æ•—ã€‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’è©¦ã¿ã¾ã™ã€‚", e);
        }
      }

      // --- è¨­å®šãƒ‡ãƒ¼ã‚¿ ---
      // å¹´ã”ã¨ã®è‰²å®šç¾©ï¼ˆãƒ‘ã‚¹ãƒ†ãƒ«ã‚«ãƒ©ãƒ¼ã§åŒºåˆ¥ï¼‰
      const yearColors = {
        "2021": "#4fc3f7", // æ°´è‰²
        "2022": "#81c784", // ç·‘
        "2023": "#fff176", // é»„è‰²
        "2024": "#ffb74d", // ã‚ªãƒ¬ãƒ³ã‚¸
        "2025": "#e57373"  // èµ¤
      };

      const prefCoords = {
        "åŒ—æµ·é“": [142.7, 43.4], "é’æ£®": [140.7, 40.8], "å²©æ‰‹": [141.15, 39.7], "å®®åŸ": [140.87, 38.26], "ç§‹ç”°": [140.1, 39.7],
        "å±±å½¢": [140.36, 38.24], "ç¦å³¶": [140.47, 37.75], "èŒ¨åŸ": [140.4, 36.34], "æ ƒæœ¨": [139.88, 36.56], "ç¾¤é¦¬": [139.06, 36.39],
        "åŸ¼ç‰": [139.63, 35.85], "åƒè‘‰": [140.12, 35.6], "æ±äº¬": [139.69, 35.68], "ç¥å¥ˆå·": [139.64, 35.44], "æ–°æ½Ÿ": [139.02, 37.9],
        "å¯Œå±±": [137.21, 36.69], "çŸ³å·": [136.65, 36.59], "ç¦äº•": [136.22, 36.06], "å±±æ¢¨": [138.56, 35.66], "é•·é‡": [138.18, 36.65],
        "å²é˜œ": [136.72, 35.39], "é™å²¡": [138.38, 34.97], "æ„›çŸ¥": [136.9, 35.18], "ä¸‰é‡": [136.5, 34.73], "æ»‹è³€": [135.86, 35.0],
        "äº¬éƒ½": [135.75, 35.02], "å¤§é˜ª": [135.5, 34.68], "å…µåº«": [135.18, 34.69], "å¥ˆè‰¯": [135.83, 34.68], "å’Œæ­Œå±±": [135.16, 34.22],
        "é³¥å–": [134.23, 35.5], "å³¶æ ¹": [133.05, 35.47], "å²¡å±±": [133.93, 34.66], "åºƒå³¶": [132.45, 34.39], "å±±å£": [131.47, 34.18],
        "å¾³å³¶": [134.55, 34.06], "é¦™å·": [134.04, 34.34], "æ„›åª›": [132.76, 33.84], "é«˜çŸ¥": [133.53, 33.55], "ç¦å²¡": [130.41, 33.6],
        "ä½è³€": [130.29, 33.24], "é•·å´": [129.87, 32.74], "ç†Šæœ¬": [130.74, 32.78], "å¤§åˆ†": [131.61, 33.23], "å®®å´": [131.42, 31.91],
        "é¹¿å…å³¶": [130.55, 31.56], "æ²–ç¸„": [127.68, 26.21]
      };

      const bearDataRaw = {
        "2021": [["åŒ—æµ·é“",0],["é’æ£®",151],["å²©æ‰‹",1169],["å®®åŸ",331],["ç§‹ç”°",274],["å±±å½¢",113],["ç¦å³¶",129],["èŒ¨åŸ",0],["æ ƒæœ¨",21],["ç¾¤é¦¬",196],["åŸ¼ç‰",16],["åƒè‘‰",0],["æ±äº¬",15],["ç¥å¥ˆå·",26],["æ–°æ½Ÿ",286],["å¯Œå±±",77],["çŸ³å·",119],["ç¦äº•",175],["å±±æ¢¨",68],["é•·é‡",304],["å²é˜œ",105],["é™å²¡",37],["æ„›çŸ¥",3],["ä¸‰é‡",3],["æ»‹è³€",25],["äº¬éƒ½",236],["å¤§é˜ª",2],["å…µåº«",112],["å¥ˆè‰¯",4],["å’Œæ­Œå±±",24],["é³¥å–",33],["å³¶æ ¹",231],["å²¡å±±",33],["åºƒå³¶",177],["å±±å£",66]],
        "2022": [["åŒ—æµ·é“",0],["é’æ£®",152],["å²©æ‰‹",1051],["å®®åŸ",237],["ç§‹ç”°",383],["å±±å½¢",187],["ç¦å³¶",190],["èŒ¨åŸ",0],["æ ƒæœ¨",13],["ç¾¤é¦¬",170],["åŸ¼ç‰",24],["åƒè‘‰",0],["æ±äº¬",27],["ç¥å¥ˆå·",16],["æ–°æ½Ÿ",262],["å¯Œå±±",99],["çŸ³å·",149],["ç¦äº•",167],["å±±æ¢¨",48],["é•·é‡",200],["å²é˜œ",94],["é™å²¡",10],["æ„›çŸ¥",1],["ä¸‰é‡",6],["æ»‹è³€",15],["äº¬éƒ½",214],["å¤§é˜ª",5],["å…µåº«",97],["å¥ˆè‰¯",18],["å’Œæ­Œå±±",21],["é³¥å–",40],["å³¶æ ¹",235],["å²¡å±±",30],["åºƒå³¶",135],["å±±å£",80]],
        "2023": [["åŒ—æµ·é“",0],["é’æ£®",247],["å²©æ‰‹",1642],["å®®åŸ",253],["ç§‹ç”°",384],["å±±å½¢",244],["ç¦å³¶",216],["èŒ¨åŸ",0],["æ ƒæœ¨",50],["ç¾¤é¦¬",224],["åŸ¼ç‰",28],["åƒè‘‰",0],["æ±äº¬",22],["ç¥å¥ˆå·",12],["æ–°æ½Ÿ",270],["å¯Œå±±",98],["çŸ³å·",74],["ç¦äº•",146],["å±±æ¢¨",43],["é•·é‡",381],["å²é˜œ",226],["é™å²¡",18],["æ„›çŸ¥",8],["ä¸‰é‡",6],["æ»‹è³€",34],["äº¬éƒ½",267],["å¤§é˜ª",1],["å…µåº«",149],["å¥ˆè‰¯",18],["å’Œæ­Œå±±",8],["é³¥å–",33],["å³¶æ ¹",321],["å²¡å±±",24],["åºƒå³¶",145],["å±±å£",98]],
        "2024": [["åŒ—æµ·é“",0],["é’æ£®",314],["å²©æ‰‹",1439],["å®®åŸ",322],["ç§‹ç”°",453],["å±±å½¢",145],["ç¦å³¶",304],["èŒ¨åŸ",0],["æ ƒæœ¨",118],["ç¾¤é¦¬",335],["åŸ¼ç‰",25],["åƒè‘‰",0],["æ±äº¬",80],["ç¥å¥ˆå·",36],["æ–°æ½Ÿ",356],["å¯Œå±±",127],["çŸ³å·",135],["ç¦äº•",410],["å±±æ¢¨",116],["é•·é‡",474],["å²é˜œ",314],["é™å²¡",49],["æ„›çŸ¥",7],["ä¸‰é‡",38],["æ»‹è³€",41],["äº¬éƒ½",578],["å¤§é˜ª",3],["å…µåº«",231],["å¥ˆè‰¯",50],["å’Œæ­Œå±±",40],["é³¥å–",50],["å³¶æ ¹",571],["å²¡å±±",33],["åºƒå³¶",217],["å±±å£",184]],
        "2025": [["åŒ—æµ·é“",0],["é’æ£®",492],["å²©æ‰‹",1562],["å®®åŸ",258],["ç§‹ç”°",1292],["å±±å½¢",427],["ç¦å³¶",294],["èŒ¨åŸ",1],["æ ƒæœ¨",59],["ç¾¤é¦¬",177],["åŸ¼ç‰",40],["åƒè‘‰",0],["æ±äº¬",18],["ç¥å¥ˆå·",25],["æ–°æ½Ÿ",592],["å¯Œå±±",90],["çŸ³å·",137],["ç¦äº•",266],["å±±æ¢¨",112],["é•·é‡",344],["å²é˜œ",267],["é™å²¡",21],["æ„›çŸ¥",4],["ä¸‰é‡",24],["æ»‹è³€",64],["äº¬éƒ½",299],["å¤§é˜ª",2],["å…µåº«",209],["å¥ˆè‰¯",56],["å’Œæ­Œå±±",19],["é³¥å–",18],["å³¶æ ¹",259],["å²¡å±±",16],["åºƒå³¶",141],["å±±å£",66]]
      };

      let map;
      let threeContainer;

      async function boot() {
        const loadingEl = document.getElementById('loading');
        const titleEl = loadingEl.querySelector('h2');

        // ã‚¹ãƒ†ãƒƒãƒ—1: Base64ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã‹ç¢ºèª
        if (!japanMapData && mapDataBase64 && !mapDataBase64.includes("<?")) {
          if (titleEl) titleEl.textContent = 'ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒä¸­...';
          const jsonStr = decodeBase64(mapDataBase64);
          if (jsonStr) {
            try {
              japanMapData = JSON.parse(jsonStr);
              console.log('âœ… Base64ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å¾©å…ƒæˆåŠŸ');
            } catch (e) {
              console.warn('Base64ãƒ‡ãƒ¼ã‚¿ã®è§£æã«å¤±æ•—:', e);
              japanMapData = null;
            }
          }
        }

        // ã‚¹ãƒ†ãƒƒãƒ—2: ãƒ‡ãƒ¼ã‚¿ãŒãªã‘ã‚Œã° CDN ã‹ã‚‰å–å¾—
        if (!japanMapData) {
          try {
            if (titleEl) titleEl.textContent = 'åœ°å›³ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...';

            const candidates = [
              'https://raw.githubusercontent.com/dataofjapan/land/master/japan.geojson',
              'https://unpkg.com/geojson-japan@0.2.0/japan.geo.json',
              'https://cdn.jsdelivr.net/npm/geojson-japan@0.2.0/japan.geo.json'
            ];

            async function tryFetch(url) {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 20000);
              
              try {
                const res = await fetch(url, { 
                  cache: 'default',
                  mode: 'cors',
                  signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                
                // ãƒ‡ãƒ¼ã‚¿å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
                if (!data.features || data.features.length === 0) {
                  throw new Error('GeoJSON ã« features ãŒã‚ã‚Šã¾ã›ã‚“');
                }
                
                const hasCoordinates = data.features.some(f => 
                  f.geometry && f.geometry.coordinates && 
                  JSON.stringify(f.geometry.coordinates).length > 100
                );
                if (!hasCoordinates) {
                  throw new Error('åº§æ¨™ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                console.log('âœ… ' + url + ' ã‹ã‚‰å–å¾—æˆåŠŸ:', data.features.length + ' features');
                return data;
              } catch (e) {
                clearTimeout(timeoutId);
                throw e;
              }
            }

            let lastErr;
            for (const url of candidates) {
              try {
                const displayUrl = url.split('/').pop();
                if (titleEl) titleEl.textContent = `å–å¾—ä¸­: ${displayUrl}`;
                console.log('ğŸ“¥ è©¦è¡Œ:', displayUrl);
                
                japanMapData = await tryFetch(url);
                break;
              } catch (e) {
                console.warn('âŒ å¤±æ•—:', url, e.message);
                lastErr = e;
              }
            }
            
            if (!japanMapData) {
              throw lastErr || new Error('ã™ã¹ã¦ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
            }
          } catch (e) {
            console.error('âŒ ã‚¨ãƒ©ãƒ¼:', e.message);
            loadingEl.innerHTML = `
              <h2>âš ï¸ åœ°å›³ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—</h2>
              <p>${e.message}</p>
              <p style="font-size:12px; color:#999;">
                ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã®ã†ãˆã€<br>
                ãƒ–ãƒ©ã‚¦ã‚¶ã‚’å†èª­ã¿è¾¼ã¿ (Ctrl+F5) ã—ã¦ãã ã•ã„
              </p>
            `;
            return;
          }
        }

        // ã‚¹ãƒ†ãƒƒãƒ—3: ECharts ã«ç™»éŒ²ã—ã¦è¡¨ç¤º
        try {
          if (titleEl) titleEl.textContent = 'åœ°å›³ã‚’åˆæœŸåŒ–ä¸­...';
          console.log('ğŸ—ºï¸ MapLibre GL ã‚’åˆæœŸåŒ–ä¸­...');
          
          initMap();
          initChart();
        } catch (e) {
          console.error('âŒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', e);
          loadingEl.innerHTML = 
            "âš ï¸ åœ°å›³ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚<br><small>" + e.message + "</small>";
        }
      }

      function initMap() {
        map = new maplibregl.Map({
          container: 'map',
          style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
          center: [138, 37],
          zoom: 4.5,
          pitch: 45,
          bearing: 0,
          antialias: true
        });
        
        map.on('load', () => {
          console.log('âœ… MapLibre GL ãƒ­ãƒ¼ãƒ‰å®Œäº†');
          addDataLayer();
        });
      }

      function addDataLayer() {
        const currentYear = "All";
        const data = getStackedSeries(currentYear);
        
        // GeoJSON ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œæˆï¼ˆPolygonï¼‰
        const features = data.map(series => {
          return series.data.map(item => {
            const [lng, lat] = [item.value[0], item.value[1]];
            const height = item.value[3] * 5000;  // é«˜ã•ã‚’5000å€ã«æ‹¡å¤§
            // å¹´ã«å¿œã˜ã¦å°‘ã—ãšã¤ç´°ãã™ã‚‹ï¼ˆ2021å¹´ã‚’åŸºæº–ã«å¹´ãŒé€²ã‚€ã”ã¨ã«ç´°ãã™ã‚‹ï¼‰
            let size = 0.12;
            const yearNum = parseInt(series.name);
            if (!isNaN(yearNum)) {
              // å¹´å·®ã«å¿œã˜ã¦å¹…ã‚’æ¸›ã‚‰ã™ã€‚1å¹´ã‚ãŸã‚Š 0.015 ã‚’æ¸›å°‘ï¼ˆä¾‹: 2021â†’0.12, 2025â†’0.06ï¼‰
              size = Math.max(0.02, 0.12 - (yearNum - 2021) * 0.015);
            }
            // åº§æ¨™ã‚’ä¸­å¿ƒã¨ã—ãŸæ­£æ–¹å½¢ Polygon ã‚’ä½œæˆ
            const coords = [
              [lng - size, lat - size],
              [lng + size, lat - size],
              [lng + size, lat + size],
              [lng - size, lat + size],
              [lng - size, lat - size]
            ];
            
            return {
              type: 'Feature',
              properties: {
                name: item.name,
                value: item.value[2],
                height: height,
                year: series.name,
                color: series.itemStyle.color
              },
              geometry: {
                type: 'Polygon',
                coordinates: [coords]
              }
            };
          });
        }).flat();

        const geojson = {
          type: 'FeatureCollection',
          features: features
        };

        // ã‚½ãƒ¼ã‚¹ã¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½åŠ 
        if (!map.getSource('bear-data')) {
          map.addSource('bear-data', {
            type: 'geojson',
            data: geojson
          });

          // Fill Extrusion ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§å††æŸ±çŠ¶ã«è¡¨ç¤º
          map.addLayer({
            id: 'bear-3d',
            type: 'fill-extrusion',
            source: 'bear-data',
            paint: {
              'fill-extrusion-color': ['get', 'color'],
              'fill-extrusion-height': ['get', 'height'],
              'fill-extrusion-base': 0,
              'fill-extrusion-opacity': 0.8
            }
          });

          // ãƒ›ãƒãƒ¼æ™‚ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³
          map.on('mousemove', 'bear-3d', (e) => {
            map.getCanvas().style.cursor = 'pointer';
            const props = e.features[0].properties;
            document.getElementById('legendArea').innerHTML = `
              <strong>${props.name}</strong><br>
              ${props.year}å¹´: ${props.value} ä»¶
            `;
          });

          map.on('mouseleave', 'bear-3d', () => {
            map.getCanvas().style.cursor = '';
            updateLegend("All");
          });
        } else {
          // æ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
          map.getSource('bear-data').setData(geojson);
        }
      }

      function updateLegend(year) {
        const legendDiv = document.getElementById('legendArea');
        if (year === "All") {
          legendDiv.innerHTML = `
            <span style="font-weight:bold; margin-right:10px;">ç©ã¿ä¸Šã’è¡¨ç¤º:</span>
            <div class="legend-item"><div class="color-box" style="background:${yearColors['2025']}"></div>2025</div>
            <div class="legend-item"><div class="color-box" style="background:${yearColors['2024']}"></div>2024</div>
            <div class="legend-item"><div class="color-box" style="background:${yearColors['2023']}"></div>2023</div>
            <div class="legend-item"><div class="color-box" style="background:${yearColors['2022']}"></div>2022</div>
            <div class="legend-item"><div class="color-box" style="background:${yearColors['2021']}"></div>2021</div>
          `;
        }
      }

      function initChart() {
        document.getElementById('loading').style.display = 'none';

        const years = ["All", "2021", "2022", "2023", "2024", "2025"];
        const controlsDiv = document.getElementById('yearButtons');
        
        years.forEach(year => {
          const btn = document.createElement('button');
          btn.innerText = year === "All" ? "åˆè¨ˆ" : year + "å¹´";
          btn.onclick = () => updateYear(year, btn);
          if (year === "All") btn.classList.add('active');
          controlsDiv.appendChild(btn);
        });

        updateLegend("All");
      }

      function updateYear(year, btnElement) {
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        btnElement.classList.add('active');
        updateLegend(year);
        
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ›´æ–°
        const data = getStackedSeries(year);
        
        const features = data.map(series => {
          return series.data.map(item => {
            const [lng, lat] = [item.value[0], item.value[1]];
            const height = item.value[3] * 5000;  // é«˜ã•ã‚’5000å€ã«æ‹¡å¤§
            // å¹´ã«å¿œã˜ã¦å°‘ã—ãšã¤ç´°ãã™ã‚‹
            let size = 0.12;
            const yearNum = parseInt(series.name);
            if (!isNaN(yearNum)) {
              size = Math.max(0.02, 0.12 - (yearNum - 2021) * 0.015);
            }
            
            const coords = [
              [lng - size, lat - size],
              [lng + size, lat - size],
              [lng + size, lat + size],
              [lng - size, lat + size],
              [lng - size, lat - size]
            ];
            
            return {
              type: 'Feature',
              properties: {
                name: item.name,
                value: item.value[2],
                height: height,
                year: series.name,
                color: series.itemStyle.color
              },
              geometry: {
                type: 'Polygon',
                coordinates: [coords]
              }
            };
          });
        }).flat();

        const geojson = {
          type: 'FeatureCollection',
          features: features
        };

        // ã‚½ãƒ¼ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
        if (map.getSource('bear-data')) {
          map.getSource('bear-data').setData(geojson);
        }
      }

      // ãƒ‡ãƒ¼ã‚¿ã®å¤‰æ›ãƒ­ã‚¸ãƒƒã‚¯
      function getStackedSeries(targetYear) {
        const years = ["2021", "2022", "2023", "2024", "2025"];
        let seriesList = [];
        
        if (targetYear !== "All") {
          const data = convertSingleYear(targetYear);
          seriesList.push(createBarSeries(data, yearColors[targetYear] || '#d32f2f', targetYear));
        } else {
          let prefTotals = {};
          
          years.forEach(y => {
            bearDataRaw[y].forEach(item => {
              const [pref, val] = item;
              if(!prefTotals[pref]) prefTotals[pref] = {};
              prefTotals[pref][y] = val;
            });
          });

          let accum = {};
          let stackedData = [];
          for (let i = 0; i < years.length; i++) {
            const y = years[i];
            stackedData.push({ year: y, data: [] });
            
            Object.keys(prefCoords).forEach(pref => {
               const val = prefTotals[pref] ? (prefTotals[pref][y] || 0) : 0;
               if (!accum[pref]) accum[pref] = 0;
               accum[pref] += val;
               
               if (accum[pref] > 0) {
                 const coord = prefCoords[pref];
                 const height = Math.sqrt(accum[pref]) * 1.5;
                 stackedData[i].data.push({
                   name: pref,
                   value: [coord[0], coord[1], accum[pref], height],
                   originalVal: val
                 });
               }
            });
          }

          for (let i = years.length - 1; i >= 0; i--) {
            const y = years[i];
            const sData = stackedData[i].data;
            seriesList.push(createBarSeries(sData, yearColors[y], y));
          }
        }
        return seriesList;
      }

      function convertSingleYear(year) {
        const raw = bearDataRaw[year];
        const res = [];
        raw.forEach(item => {
          const [name, value] = item;
          const coord = prefCoords[name];
          if (coord && value > 0) {
            const height = Math.sqrt(value) * 1.5;
            res.push({
              name: name,
              value: [coord[0], coord[1], value, height]
            });
          }
        });
        return res;
      }

      function createBarSeries(data, color, seriesName) {
        return {
          data: data,
          itemStyle: { color: color },
          name: seriesName
        };
      }

      window.onload = boot;
    </script>
  </body>
</html>